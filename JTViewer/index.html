<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>Show File Data</title>
    <style type='text/css'>
        body {
            font-family: sans-serif;
        }
    </style>
  
</head>
<body>
    <form action='#' onsubmit="return false;">
        <input type='file' id='fileinput'>
        <input type='button' id='btnLoad' value='Load' onclick='loadFile();'>
        <input type='button' id='btnShow' value='Show' onclick='showFile();'>
    </form>
    <script src="main.js", type='text/javascript'>
    </script>
     <script src="https://threejs.org/examples/jsm/libs/stats.module.js" type="module"></script>
     <script src="https://threejs.org/build/three.module.js" type="module"></script>
     <script src="https://threejs.org/examples/jsm/controls/OrbitControls.js" type="module"></script>
     <!--<script src="three/TweenMax.min.js"></script>
     <script src="three/three.js"></script>-->
     <script src='https://threejs.org/build/three.js'></script>
     <!--<script src="https://pastebin.com/raw/spG7t73a" ></script>-->
 
     <script type="module">
 
         import { OrbitControls } from 'https://threejs.org/examples/jsm/controls/OrbitControls.js';  // Importing from OrbitControls
         import Stats from 'https://threejs.org/examples/jsm/libs/stats.module.js';
 
 
         var scene, camera, renderer, exporter, mesh, points;
 
         init();
         animate();
         function init() {
             camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);      // Settings for the Camera
             camera.position.set(200, 100, 200);     // Camera Position
             scene = new THREE.Scene();
             scene.background = new THREE.Color(0xa0a0a0);       // Background Color
             //scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);     // Creating the Fog for the Scene
 
             //
             var hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);  // Settings for the Hemisphere-Light
             hemiLight.position.set(0, 200, 0);
             scene.add(hemiLight);
             var directionalLight = new THREE.DirectionalLight(0xffffff);  // Setting for the direct Light for the Object
             directionalLight.position.set(0, 200, 100);
             directionalLight.castShadow = true;
             directionalLight.shadow.camera.top = 180;
             directionalLight.shadow.camera.bottom = - 100;
             directionalLight.shadow.camera.left = - 120;
             directionalLight.shadow.camera.right = 120;
             scene.add(directionalLight);
             // ground
             var ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })); // Adding the Objects to the Ground
             ground.rotation.x = - Math.PI / 2;
             ground.receiveShadow = true;
             scene.add(ground);              // Adding the Scene
             var grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
             grid.material.opacity = 0.2;
             grid.material.transparent = true;
             scene.add(grid);

             var particles = 50000; // The Count of the Particles
				var geometry = new THREE.BufferGeometry();
				var positions = [];
				var colors = [];
				var color = new THREE.Color();
				var n = 1000, n2 = n / 2; // particles spread in the cube
				for ( var i = 0; i < particles; i ++ ) {
					// positions
					var x = Math.random() * n - n2; // till now, they are random 
					var y = Math.random() * n - n2;
					var z = Math.random() * n - n2;
					positions.push( x, y, z );
					// colors
					var vx = ( x / n ) + 0.5; // Colors for the particles
					var vy = ( y / n ) + 0.5;
				    var vz = ( z / n ) + 0.5;
					color.setRGB( vx, vy, vz );
					colors.push( color.r, color.g, color.b );
				}
				geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.computeBoundingSphere();



                var material = new THREE.PointsMaterial( { size: 12, vertexColors: THREE.VertexColors } ); // Material for the Points
				points = new THREE.Points( geometry, material );
				scene.add( points );

             // export mesh
            // var geometry = new THREE.BoxBufferGeometry(50, 50, 50);  // getting the Geometry of a Box from ThreeJS
            // var vertices = [
            // 0.5,  10, 0,
            // 10, -10, 0,
            // -10,  10, 0,
            // -10, -10, 0
            //];
            //var geometry = new THREE.BufferGeometry();
            //geometry.addAttribute( 
  	        //'position', 
            //new THREE.BufferAttribute( new Float32Array( vertices ),3 )) ;

            // var material = new THREE.MeshPhongMaterial({ color: 0xFF0000 }); // getting the Material for the Object and Color
             //mesh = new THREE.Mesh(geometry, material); // Creating the Object
             //mesh.castShadow = true;
             //mesh.position.y = 25;
             //scene.add(mesh);
             //
             renderer = new THREE.WebGLRenderer({ antialias: true });                // Rendering
             renderer.setPixelRatio(window.devicePixelRatio);
             renderer.setSize(window.innerWidth, window.innerHeight);
             renderer.shadowMap.enabled = true;
             document.body.appendChild(renderer.domElement);
             //
             var controls = new OrbitControls(camera, renderer.domElement); // Settings for Controlling the Object
             controls.target.set(0, 25, 0);
             controls.update();
             //
             window.addEventListener('resize', onWindowResize, false); // To Relocate the Object
 
         }
         function onWindowResize() {                                     // Keep the Shape of the Objects in the Window
             camera.aspect = window.innerWidth / window.innerHeight;
             camera.updateProjectionMatrix();
             renderer.setSize(window.innerWidth, window.innerHeight);
         }
         function animate() {
             requestAnimationFrame(animate);
             renderer.render(scene, camera);
         }
 
     </script>
</body>
</html>